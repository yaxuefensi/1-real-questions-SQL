考了一题sql，有陷阱，中间夹了产品的问题. 牛人云集,一亩三分地
table frieding：date，action（‘send’，‘accept’），user_id，target_id
计算acceptance rate treding by time
每个用户能发送一次，每个用户也只能接受一次，a发了request给b，b就不能发送给a，只能接受或忽略。
如果a发送request给b，b接受了才能认为是accept，否则不算。
我当时问了时间长度的问题，被反问觉得应该选择多长的时间？
我直觉说了一句monthly，问为什么是monthly，想了想说应该算average frequency for send or accept，再根据这个定时间。
追问用现有表格如何算average frequency？说了一下。
最后让用一个月为期限，算acceptance rate。


同楼上，我也觉得acceptance rate只要用overall的就行了，其实对于business来说是很make sense了的，而且比较actionable. 如果考官追
问要perfect match每一个request和accept那再去研究具体的。而且对于time window，取一个percentile可能更好一些，比如90%，用来包括大多数的accept。

我觉得 第一题选择时间window 应该用所有已经成为朋友的用户data 算 accept.date - sent.date 的平均值，而不是看频率

这题里面应该还有个time window，就是你准备计算多久的trending，总不能把n年前的数据全算出来吧？
反正这个我没有想明白，但是算多久的数据呢？我个人觉得展示半年或一季度，但是这个time window的根据是什么？
包括这个acceptance rate，是要计算每天的吗？还是计算一个星期的？全是坑啊！
我后面都不敢多问了，怕给自己挖坑。


时间window的问题是不是应该答average（accept- send）？ 这个是不是看看最近的数据就可以了？ 最近几个月最多一年？ 
还是系统可能有限制，应该用那个限制？

或者是我想简单了？如果写错了求帮忙纠正啊！. 1point3acres
既然每个用户能发送一次，每个用户也只能接受一次，a发了request给b，b就不能发送给a，只能接受或忽略，所以这个table大概是这个样子：
Date        action        User_id        Target_id
31-May        Send        1        2
1-Jun        Accept        2        1
2-Jun        send                1      3
3-Jun        Accept        3        1. Waral 博客有更多文章,
4-Jun        Send        2        4
5-Jun        ？             4        2
6-Jun        Send         3        4
7-Jun        ？             4        3
.本文原创自1point3acres论坛
然后就是成对出现，就成了下面的code：

Select Date, sum(case when action=’Accept’ then 1 else 0)/Sum(case when action=’Send’ then 1 else 0)
As acceptance_rate from friending group by Date order by date;


补充内容 (2018-6-5 07:53):
丢了end..... more info on 1point3acres
Select Date, sum(case when action=’Accept’ then 1 else 0 end)/Sum(case when action=’Send’ then 1 else 0 end)
As acceptance_rate from friending group by Date order by date;

我当时怀疑我听错了，一开始写了overall rate，面试官说不对，他说要一对一match才算。
所以有一个time window，某个时间段内的request可以accept，超过这个时间段就没办法accept。他当时还反问我，如果2年前的一个request，
2年后也能被accept吗？我回答不能，他问多久之内的能accept，这个time window怎么算？
我觉得平均值有点不对，应该是过去接受和发送之间的最大值，但不能是outlier。如果以平均值作为time window，那超过平均时长的request是
能被接受的。实际的产品里，好像超过几天的request就过期了，微信fb qq都有这样的机制，所以用户发送和接受的时差肯定< time window。

I think below query would make more sense. Group by the date when the request was sent. You can always add a date range condition by adding another AND statement following the LEFT JOIN.

SELECT s.date
             , SUM(CASE WHEN a.action='accept' THEN 1 ELSE NULL END)/COUNT(s.user_id) AS acceptance_rate
      FROM (SELECT date. 1point3acres
                                 , user_id. 牛人云集,一亩三分地
                                 , target_id
                         FROM friending 
                        WHERE action='send') s. 围观我们@1point 3 acres
     LEFT JOIN friending a
    ON s.user_id=a.target_id
   AND s.target_id=a.user_id
-- AND a.date - s.date <= 30    ---additional criteria. visit 1point3acres for more.
GROUP BY s.date
ORDER BY s.date

